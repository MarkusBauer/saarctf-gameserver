volumes:
  postgres:
  redis:
  scoreboard:

# TODO for you:
# - persistence (see volumes above)
# - restart policies
# - writing config file
# - define worker concurrency (etc)

services:
  postgres:
    image: postgres:17.2
    environment:
      - POSTGRES_DB
      - POSTGRES_USER
      - POSTGRES_PASSWORD
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - postgres:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      interval: 10s
      timeout: 1s
      retries: 30

  rabbitmq:
    image: rabbitmq:4.0-management
    healthcheck:
      test: [ "CMD", "rabbitmq-diagnostics", "-q", "ping" ]
      interval: 10s
      timeout: 1s
      retries: 30
    environment:
      - RABBITMQ_DEFAULT_USER
      - RABBITMQ_DEFAULT_PASS
      - RABBITMQ_DEFAULT_VHOST
    ports:
      - "127.0.0.1:5672:5672"

  redis:
    image: redis:7.4-alpine
    command: "redis-server --save 60 1 --loglevel warning"
    volumes:
      - redis:/data
    ports:
      - "127.0.0.1:6379:6379"

  migrate:
    image: "saarctf/app"
    build: .
    volumes:
      - ./config.docker.yaml:/opt/config.yaml:ro
    command: "-m alembic upgrade head"
    depends_on:
      postgres:
        condition: service_healthy

  cp:
    image: "saarctf/app"
    build: .
    volumes:
      - ./config.docker.yaml:/opt/config.yaml:ro
      - scoreboard:/scoreboard
    ports:
      - "5000:5000"
    command: ["-m", "gunicorn", "--bind", "0.0.0.0:5000", "--log-level", "info", "controlserver.wsgi:app"]
    depends_on:
      migrate:
        condition: service_completed_successfully
      postgres:
        condition: service_healthy
        restart: true
      redis:
        condition: service_started

  flower:
    image: "saarctf/app"
    build: .
    volumes:
      - ./config.docker.yaml:/opt/config.yaml:ro
    ports:
      - "5555:5555"
    command: "-m celery -A checker_runner.celery_cmd flower --port=5555"
    stop_grace_period: "2s"
    environment:
      FLOWER_UNAUTHENTICATED_API: "1"
    depends_on:
      redis:
        condition: service_started
      rabbitmq:
        condition: service_healthy
        restart: true

  checker:
    image: "saarctf/app"
    build: .
    volumes:
      - ./config.docker.yaml:/opt/config.yaml:ro
    command: "-m celery -A checker_runner.celery_cmd worker -Ofair -E -Q celery,tests,broadcast --concurrency=${CHECKER_CONCURRENCY}"
    ulimits:
      nofile: 65536
      nproc: 65536
    stop_grace_period: "1m"  # let started checker tasks finish gracefully
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
      rabbitmq:
        condition: service_healthy

  timer:
    image: "saarctf/app"
    build: .
    volumes:
      - ./config.docker.yaml:/opt/config.yaml:ro
      - scoreboard:/scoreboard
    command: ["controlserver/master_timer.py"]
    ulimits:
      nofile: 16384
    depends_on:
      migrate:
        condition: service_completed_successfully
      postgres:
        condition: service_healthy
        restart: true  # just to be safe, shouldn't be necessary
      redis:
        condition: service_started
      rabbitmq:
        condition: service_healthy
        restart: true

  submitter:
    image: "saarctf/submitter"
    build: flag-submission-server
    volumes:
      - ./config.docker.yaml:/config.yaml:ro
    ports:
      - "31337:31337"
    ulimits:
      nofile: 16384
    depends_on:
      migrate:
        condition: service_completed_successfully
      postgres:
        condition: service_healthy
        restart: true
      redis:
        condition: service_started
        restart: true

  # scoreboard "host", not the scoreboard daemon for off-site scoreboard generation
  # in this setting, the scoreboard is generated by the ctftimer, and written to a volume
  scoreboard:
    image: nginx
    volumes:
      - "scoreboard:/usr/share/nginx/html:ro"
    ports:
      - "5001:80"
